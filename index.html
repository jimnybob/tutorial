<!DOCTYPE html><html><head><link href="META-INF/resources/webjars/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><link rel="shortcut icon" type="image/png" href="favicon.png" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800px;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><title>A Whirlwind Tour of Scalameta</title><script src="scripts.js"></script></head><body><div>


  <a href="https://github.com/olafurpg/scala.meta-workshop"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="AWhirlwindTourofScalameta" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">A Whirlwind Tour of Scalameta<a class=" scalatex-site-Styles-headerLink" href="#AWhirlwindTourofScalameta" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
  <p>
    For any Scalameta related questions, don't hesitate to ask on our gitter channel:
    <a href="https://gitter.im/scalameta/scalameta?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/scalameta/scalameta" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a></p>
  <p>
    <b>Note.</b> This tutorial was originally created for a workshop at the
    <a href="http://scala.world">scala.world</a> conference.
    The workshop material turned out to be useful for many so it has been moved here.
    You will still find occasional references to scala.world.</p>
  


  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Setup" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Setup<a class=" scalatex-site-Styles-headerLink" href="#Setup" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  There are several ways to install and run Scalameta.

  <h1 id="Library" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Library" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Library</h1>
    You can use Scalameta as a library, the <code>scalameta</code> umbrella package
    includes modules for trees, tokens, parsing, pretty printing, semantic API
    and more,
    <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;org.scalameta&quot; %% &quot;scalameta&quot; % &quot;1.8.0&quot;
</code></pre>
    Optionally, for extra utilities, you can use <a href="#Contrib">Contrib</a>
    <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;org.scalameta&quot; %% &quot;contrib&quot; % &quot;1.8.0&quot;
</code></pre>
  <h1 id="Tutorial" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tutorial" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tutorial</h1>
    The examples mentioned in this tutorial are available in a single repository
    that you can clone and run locally.
    <ol>
      <li>
        Clone the <a href="https://github.com/scalameta/tutorial">workshop repo</a>.
        Alternatively, for a minimal project template that uses the bleeding edge
        version of scalameta/paradise, clone
        <a href="https://github.com/olafurpg/scalameta-macro-template">this repo</a>.</li>
      <li>
        Run <code>sbt test</code> to make sure everything works.</li>
      <li>
        Open the file <code>Playground.scala</code>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld

import scala.meta._
import org.scalameta.logger // useful for debugging

class Playground extends org.scalatest.FunSuite {
  import scala.meta._

  test(&quot;part 1: tokens&quot;) {
    val tokens = &quot;val x = 2&quot;.tokenize.get
    logger.elem(tokens.syntax)
    logger.elem(tokens.structure)
  }

  test(&quot;part 2: trees&quot;) {
    val tree = &quot;val x = 2&quot;.parse[Stat].get
    logger.elem(tree.syntax)
    logger.elem(tree.structure)
  }

}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/tutorial/tree/master/library/src/test/scala/scalaworld/Playground.scala#L0-L21" target="_blank"><i class="fa fa-link "></i></a></pre></li>
      <li>
        To test playground on every edit, run <code>sbt ~library/test</code>.</li>
      <li>
        Setup the project in your favorite IDE, for example IntelliJ, ENSIME or vim.
</li></ol>
  <h1 id="AmmoniteREPL" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#AmmoniteREPL" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Ammonite REPL</h1>
    To experiment with Scalameta in the REPL, you can run the following
    in the <a href="http://www.lihaoyi.com/Ammonite/#Ammonite-REPL">Ammonite REPL</a>
    <pre><code class="scala scalatex-site-Styles-highlightMe">import $ivy.`org.scalameta:scalameta_2.11:1.8.0`, scala.meta._</code></pre>
    <b>Note.</b> The macro annotation examples will not run in the REPL, follow
    <a href="https://github.com/scalameta/paradise/issues/10">scalameta/paradise#10</a>
    for updates.

  <h1 id="Video" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Video" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Video</h1>
    <p>
      To accompany the workshop, here is the recording from the original
      scala.world conference talk.</p>
    
      <iframe width="100%" style="height: 28em" src="https://www.youtube.com/embed/-l7pV0sFq1c" frameborder="0" allowfullscreen></iframe>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Tokens" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Tokens<a class=" scalatex-site-Styles-headerLink" href="#Tokens" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    Make sure you have Scalameta installed as a library from <a href="#Setup">Setup</a>.

    You can decide to run these examples from the console or from sbt,
    for example in the tutorial repo.
</p>
  <p>
    This whole workshop will assume you have this import in scope:
</p>
  <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; import scala.meta._
import scala.meta._</code></pre>
  <p>
    Here's how to tokenize a small expression.

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get
res0: scala.meta.tokens.Tokens = Tokens(, val,  , x,  , =,  , 2, )</code></pre>
    Let's discuss the most interesting methods on tokens.

    <h1 id="Tokens.syntax" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokens.syntax" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens.syntax</h1>
      <p>
        The simplest method we can call is <code>Tokens.syntax</code>
        The method returns a string representation of the actual code behind
        the tokens, or how the code should look like to a developer.
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.syntax
res0: String = val x = 2</code></pre>
      <p>
        <code>Tokens.toString()</code> uses <code>.syntax</code> behind the scenes.
        However, you should never rely on <code>toString()</code> when manipulating
        Scalameta structures, prefer to explicitly call <code>.syntax</code>.
        It's maybe not so obvious why right now but it will make more sense soon.
</p>
    <h1 id="Tokens.structure" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokens.structure" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens.structure</h1>
      <p>
        Another useful method is <code>Tokens.structure</code>.
        The method shows details that may be relevant to us as metaprogrammers.

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.structure
res0: String = Tokens(BOF [0..0), val [0..3),   [3..4), x [4..5),   [5..6), = [6..7),   [7..8), 2 [8..9), EOF [9..9))</code></pre></p>
      <p>
        <code>.structure</code> is often useful for debugging and testing.
</p>
    <h1 id="Tokensvs.Token" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokensvs.Token" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens vs. Token</h1>
      <p>
        The class <code>Tokens</code> is a wrapper around a sequence of <code>Token</code> objects.
        There are multiple subtypes of <code>Token</code> while there only one type <code>Tokens</code>.

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.head
res0: scala.meta.tokens.Token =</code></pre></p>
       <code>BOF</code> stands for &quot;Beginning of file&quot;.
       Let's see what other kinds of token types are in the string

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.
  map(x =&gt; f&quot;${x.structure}%10s -&gt; ${x.productPrefix}&quot;).
  mkString(&quot;\n&quot;)
res0: String =
BOF [0..0) -&gt; BOF
val [0..3) -&gt; KwVal
    [3..4) -&gt; Space
  x [4..5) -&gt; Ident
    [5..6) -&gt; Space
  = [6..7) -&gt; Equals
    [7..8) -&gt; Space
  2 [8..9) -&gt; Int
EOF [9..9) -&gt; EOF</code></pre>
        <p>
          Even spaces get their own tokens.
          The <code>[0...3)</code> part indicates that the <code>val</code> tokens start at
          offset 0 and ends at offset 3.
</p>
    <h1 id="==" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#==" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>==</h1>
      <p>
        How does token equality look like?
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1) == &quot;foobar kas&quot;.tokenize.get(1)
res0: Boolean = false</code></pre>
      Huh, why are they not the same?

      <div class="bs-callout bs-callout-warning"><p>
        Token equality is implemented with reference equality.
        You need to be explicit if you actually mean syntactic (<code>.syntax</code>),
        or structural (<code>.structure</code>) equality.
</p></div>
      The tokens are syntactically equal.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1).syntax == &quot;foobar kas&quot;.tokenize.get(1).syntax
res0: Boolean = true</code></pre>
      Even if we move the tokens around

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;kas foobar&quot;.tokenize.get(3).syntax == &quot;foobar kas&quot;.tokenize.get(1).syntax
res0: Boolean = true</code></pre>
      The tokens are also structurally equal.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1).structure == &quot;foobar kas&quot;.tokenize.get(1).structure
res0: Boolean = true</code></pre>
      However, they are not structurally equal if we move them around.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;kas foobar&quot;.tokenize.get(3).structure == &quot;foobar kas&quot;.tokenize.get(1).structure
res0: Boolean = false</code></pre>
    <h1 id=".get" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#.get" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>.get</h1>
      <p>
        Tokenization can sometimes fail, for example in this case:

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;&quot;&quot; val str = &quot;unclosed literal &quot;&quot;&quot;.tokenize
res0: scala.meta.tokenizers.Tokenized =
&lt;input&gt;:1: error: unclosed string literal
val str = &quot;unclosed literal
           ^</code></pre>
        <p>
          If you prefer, you can safely pattern match on the tokenize result

          <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;&quot;&quot; val str = &quot;closed literal&quot; &quot;&quot;&quot;.tokenize match {
  case tokenizers.Tokenized.Success(tokenized) =&gt; tokenized
  case tokenizers.Tokenized.Error(e, _, _) =&gt; ???
}
res0: scala.meta.tokens.Tokens = Tokens(,  , val,  , str,  , =,  , &quot;closed literal&quot;,  , )</code></pre></p></p></p>
  <h1 id="Conclusion" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Conclusion" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Conclusion</h1>
    <p>
      Scalameta tokens are the foundation of Scalameta.
      Sometimes you don't have access to a parsed AST and then your best shot is
      work with tokens.
</p>
    <p>
      In the following chapter we will discuss another exciting data structure:
      the incredible <b>scala.meta.Tree</b>.</p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Trees" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Trees<a class=" scalatex-site-Styles-headerLink" href="#Trees" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    Reminder. We assume you have this import in scope:
</p>
  <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; import scala.meta._
import scala.meta._</code></pre>
  <h1 id="q&quot;Quasiquotes&quot;" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#q&quot;Quasiquotes&quot;" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>q&quot;Quasiquotes&quot;</h1>
    <p>
      The easiest way to get started with Scalameta trees is using quasiquotes.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;case class User(name: String, age: Int)&quot;
res0: meta.Defn.Class = case class User(name: String, age: Int)</code></pre>
    <p>
      Quasiquotes can be composed
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; val method = q&quot;def `is a baby` = age &lt; 1&quot;
method: meta.Defn.Def = def `is a baby` = age &lt; 1

scala&gt; q&quot;&quot;&quot;
case class User(name: String, age: Int) {
  $method
}
&quot;&quot;&quot;
res0: meta.Defn.Class = case class User(name: String, age: Int) { def `is a baby` = age &lt; 1 }</code></pre>
    <p>
      Quasiquotes can also be used to deconstruct trees with pattern matching
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def `is a baby` = age &lt; 1&quot; match {
  case q&quot;def $name = $body&quot; =&gt;
    s&quot;You ${name.syntax} if your ${body.syntax}&quot;
}
res0: String = You `is a baby` if your age &lt; 1</code></pre>
    <div class="bs-callout bs-callout-warning"><p>
      <b>NOTE</b>. Quasiquotes currently ignore comments:

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;val x = 2 // assignment&quot;.syntax
res0: String = val x = 2</code></pre>
      If you need comments, you can use <a href="#.parse[T]">.parse[T]</a>

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2 // assignment&quot;.parse[Stat].get.syntax
res0: String = val x = 2 // assignment</code></pre></p></div>
  <h1 id=".parse[T]" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#.parse[T]" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>.parse[T]</h1>
    <p>
      If the contents that you want to parse are only known at runtime,
      you can't use quasiquotes.
      For example, this happens when you need to parse file contents.
</p>
    <p>
      Here's how to parse a compilation unit.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;object Main extends App { println(1) }&quot;.parse[Source].get
res0: scala.meta.Source = object Main extends App { println(1) }</code></pre>
    <div class="bs-callout bs-callout-success"><p>
      Pro tip. You can also call <code>.parse[T]</code> on a <code>File</code>,
      just like this

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; new java.io.File(&quot;readme/ParseMe.scala&quot;).parse[Source]
res0: scala.meta.parsers.Parsed[scala.meta.Source] =
class ParseMe { println(&quot;I'm inside a file&quot;) }</code></pre></p></div>
    <p>
      If we try to parse a statement as a compilation unit we will fail.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.parse[Source]
res0: scala.meta.parsers.Parsed[scala.meta.Source] =
&lt;input&gt;:1: error: expected class or object definition
val x = 2
^</code></pre>
    <p>
      We need to explicitly parse it as a statement (<code>Stat</code>).
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.parse[Stat].get
res0: scala.meta.Stat = val x = 2</code></pre>
    <p>
      We can also parse case statement
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;case Foo(bar) if bar &gt; 2 =&gt; println(bar)&quot;.parse[Case].get
res0: scala.meta.Case = case Foo(bar) if bar &gt; 2 =&gt; println(bar)</code></pre>
    <p>
      Scalameta has dozens of parsers:
      <div class="text-center"><img style="width: 100%" src="img/parse.png" /><p></p></div>
      However, <code>.parse[Stat]</code> and <code>.parse[Source]</code> are
      usually all you need.
</p>
  <h1 id="dialects" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#dialects" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>dialects</h1>
    <p>
      I didn't tell the whole story when I said you need to pass in a type
      argument to parse statements.
      You also need to pass in a dialect!
      However, Scalameta will by default pick the <code>Scala211</code> dialect
      for you if you don't provide one explicitly.
</p>
    <p>
      With the SBT dialects, we can parse vals as top-level statements.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; dialects.Sbt0137(
  &quot;lazy val core = project.settings(commonSettings)&quot;
).parse[Source].get
res0: scala.meta.Source = lazy val core = project.settings(commonSettings)</code></pre>
    <p>
      We can even parse multiple top level statements
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; dialects.Sbt0137(
  &quot;&quot;&quot;
  lazy val core = project.settings(commonSettings)

  lazy val extra = project.dependsOn(core)
  &quot;&quot;&quot;
).parse[Source].get
res0: scala.meta.Source =

  lazy val core = project.settings(commonSettings)

  lazy val extra = project.dependsOn(core)</code></pre>
    <p>
      For the remainder of the workshop, we will only work with the <code>Scala211</code>
      dialect.
</p>
  <h1 id="Tree.syntax" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.syntax" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.syntax</h1>
    <p>
      Just like with tokens, we can also run <code>.syntax</code> on trees.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo(bar)&quot;.parse[Stat].get.syntax
res0: String = foo(bar)</code></pre>
    However, Scalameta can also do this even if you manually construct the tree

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; Term.Apply(
  Term.Name(&quot;foo&quot;),
  scala.collection.immutable.Seq(
    Term.Name(&quot;bar&quot;): Term.Arg
  )
).syntax
res0: String = foo(bar)</code></pre>
    <p>
      We never gave Scalameta parentheses but still it figured out we needed
      them.
      Pretty cool huh.
</p>
  <h1 id="Tree.structure" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.structure" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.structure</h1>
    <p>
      Just like with tokens, we can also run <code>.structure</code> on trees.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo(bar)&quot;.parse[Stat].get.structure
res0: String = Term.Apply(Term.Name(&quot;foo&quot;), Seq(Term.Name(&quot;bar&quot;)))</code></pre>
    <p>
      <code>.structure</code> ignores any syntactic trivia like whitespace and comments
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo  ( /* this is a comment */ bar  ) // eol&quot;.parse[Stat].get.structure
res0: String = Term.Apply(Term.Name(&quot;foo&quot;), Seq(Term.Name(&quot;bar&quot;)))</code></pre>
    <p>
      This can be useful for example in debugging, testing or equality checking.
</p>
  <h1 id="Tree.collect" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.collect" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.collect</h1>
    <p>
      You can collect on Scalameta.Tree just like regular collections.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; source&quot;&quot;&quot;sealed trait Op[A]
    object Op extends B {
      case class Foo(i: Int) extends Op[Int]
      case class Bar(s: String) extends Op[String]
    }&quot;&quot;&quot;.collect { case cls: Defn.Class =&gt; cls.name }
res0: List[meta.Type.Name] = List(Foo, Bar)</code></pre>
  <h1 id="Tree.transform" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.transform" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.transform</h1>
    <p>
      Transform Scalameta.Tree with <code>.transform</code>.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;myList.filter(_ &gt; 3 + a).headOption // comments are removed :(&quot;.transform {
  case q&quot;$lst.filter($cond).headOption&quot; =&gt; q&quot;$lst.find($cond)&quot;
}
res0: scala.meta.Tree = myList.find(_ &gt; 3 + a)</code></pre>
    <div class="bs-callout bs-callout-warning"><p>
      <code>.transform</code> does not preserve syntactic details such as comments
      and formatting. There has been made some work on source aware transformation,
      see <a href="https://github.com/scalameta/scalameta/pull/457">#457</a>,
      but it still requires a bit more work.
</p></div>
  <h1 id="Tree.==" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.==" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.==</h1>
    <p>
      Just like with tokens, tree equality is by default by reference:
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot; == q&quot;foo(bar)&quot;
res0: Boolean = false</code></pre>
    This means you need to be explicit if you mean syntactic equality

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot;.syntax == q&quot;foo(bar)&quot;.syntax
res0: Boolean = true</code></pre>
    <p>
      or structural equality
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot;.structure == q&quot;foo(bar)&quot;.structure
res0: Boolean = true</code></pre>
  <h1 id="Comprehensivetrees" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Comprehensivetrees" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Comprehensive trees</h1>
    <p>
      A key feature of Scalameta trees is that they comprehensively cover
      all corners of the Scala syntax.
      A side effect of this is that the Scalameta tree hierarchy contains a
      lot of types.
      For example, there is a different tree node for an abstract <code>def</code> (<code>Decl.Def</code>)

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def add(a: Int, b: Int)&quot; // Decl.Def
res0: meta.Decl.Def = def add(a: Int, b: Int): Unit</code></pre>
      and a <code>def</code> with an implementation (<code>Defn.Def</code>)

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def add(a: Int, b: Int) = a + b&quot; // Defn.Def
res0: meta.Defn.Def = def add(a: Int, b: Int) = a + b</code></pre>
      <p>
        Fortunately, most of the time you won't need to worry about this.
        Quasiquotes help you create/match/compose/deconstruct the correct instances.
        However, occasionally you may need to debug the types of the trees you have.
</p>
      <p>
        For your convenience, I've compiled together the most common types in
        this handy diagram:
        <div class="text-center"><img style="width: 100%" src="img/tree.png" /><p></p></div></p></p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Macroannotations" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Macro annotations<a class=" scalatex-site-Styles-headerLink" href="#Macroannotations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    Scalameta makes it possible to write new-style macro annotations.  In
    comparison with
    <a href="http://docs.scala-lang.org/overviews/macros/annotations.html">the state of the art based on scala.reflect</a>,
    new-style macro annotations are:
    <ul>
      <li>
        <b>Lightweight</b>. The new macro system no longer features the split
        between macro defs and macro impls.  Moreover, writing macros no longer
        requires carrying around a context and juggling path-dependent types.
        As a result, macros can be defined with much less ceremony.</li>
      <li>
        <b>Portable</b>. New-style macros are based on a platform-independent
        metaprogramming API defined in Scalameta.  Unlike scala.reflect,
        Scalameta doesn't depend on compiler internals, so macros based on
        Scalameta can be run in a multitude of environments, including Scala,
        IntelliJ IDEA and Dotty.
</li></ul>
    In order to define a new-style macro annotation, create a class that
    extends <code>StaticAnnotation</code> and create an <code>inline</code> apply method
    with a <code>meta</code> block in it.  Inside the <code>meta</code> block, you can take
    apart the annotated member and generate new code using
    <a href="https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md">Scalameta quasiquotes</a>.
    <code>inline</code> and <code>meta</code> are new language constructs introduced by
    macro paradise 3.x.
</p>
  <h1 id="Setupbuild" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Setupbuild" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Setup build</h1>
    It's possible to write macro annotations on Scalameta trees using
    the Scalameta paradise compiler plugin.
    To configure the Scalameta paradise plugin, you need to enable it in your build
    for both the projects that define macro annotation and the projects
    that use macro annotations
    <pre><code class="scala scalatex-site-Styles-highlightMe">lazy val macroAnnotationSettings = Seq(
  addCompilerPlugin(&quot;org.scalameta&quot; % &quot;paradise&quot; % &quot;3.0.0-M9&quot; cross CrossVersion.full),
  scalacOptions += &quot;-Xplugin-require:macroparadise&quot;,
  scalacOptions in (Compile, console) := Seq() // macroparadise plugin doesn't work in repl yet.
)
lazy val projectThatDefinesMacroAnnotations = project.settings(
  libraryDependencies += &quot;org.scalameta&quot; %% &quot;scalameta&quot; % &quot;1.8.0&quot; % Provided,
  macroAnnotationSettings
  // ... your other project settings
)
lazy val projectThatUsesMacroAnnotations = project.settings(
  macroAnnotationSettings,
  // ... your other project settings
)
</code></pre>
    These settings are already configured in the tutorial repo.
    If you have cloned the tutorial repo, you can run the macro expansion
    with

  <pre><code class="scala scalatex-site-Styles-highlightMe">macros/test:run
</code></pre>
  <h1 id="HelloWorld" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HelloWorld" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Hello World</h1>
    Here is an example macro annotation:

    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.meta._
import scala.collection.immutable.Seq

class Main extends scala.annotation.StaticAnnotation {
  inline def apply(defn: Any): Any = meta {
    defn match {
      case q&quot;object $name { ..$stats }&quot; =&gt;
        MainMacroImpl.expand(name, stats)
      case _ =&gt;
        abort(&quot;@main must annotate an object.&quot;)
    }
  }
}

// This is an example how we can refactor the macro implementation into a utility
// function which can be used for unit testing, see MainUnitTest.
object MainMacroImpl {
  def expand(name: Term.Name, stats: Seq[Stat]): Defn.Object = {
    val main = q&quot;def main(args: Array[String]): Unit = { ..$stats }&quot;
    q&quot;object $name { $main }&quot;
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/tutorial/tree/master/macros/src/main/scala/scalaworld/macros/Main.scala#L0-L24" target="_blank"><i class="fa fa-link "></i></a></pre>

    The annotation wraps the body of an object into a <code>main</code> function,
    serving a similar function as extending <code>App</code>.

  <h1 id="Class2Map" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Class2Map" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Class2Map</h1>
    Implement a <code>Class2Map</code> macro annotation that injects a <code>toMap</code> method
    that creates a <code>Map[String, Any]</code> from the fields of this class.

    <p>
      Solution:
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.collection.immutable.Seq
import scala.meta._

// Before:
// @Class2Map
// class Class2MapExample(a: Int, b: String)(c: List[Int]) {
// After:
// class Class2MapExample(a: Int, b: String)(c: List[Int]) {
//   def toMap: _root_.scala.collection.Map[String, Any] =
//     _root_.scala.collection.Map((&quot;a&quot;, a), (&quot;b&quot;, b), (&quot;c&quot;, c))
// }

class Class2Map extends scala.annotation.StaticAnnotation {
  inline def apply(defn: Any): Any = meta {
    defn match {
      case cls @ Defn.Class(_, _, _, Ctor.Primary(_, _, paramss), template) =&gt;
        val namesToValues: Seq[Term.Tuple] = paramss.flatten.map { param =&gt;
          q&quot;(${param.name.syntax}, ${Term.Name(param.name.value)})&quot;
        }
        val toMapImpl: Term =
          q&quot;_root_.scala.collection.Map[String, Any](..$namesToValues)&quot;
        val toMap =
          q&quot;def toMap: _root_.scala.collection.Map[String, Any] = $toMapImpl&quot;
        val templateStats: Seq[Stat] = toMap +: template.stats.getOrElse(Nil)
        cls.copy(templ = template.copy(stats = Some(templateStats)))
      case _ =&gt;
        println(defn.structure)
        abort(&quot;@Class2Map must annotate a class.&quot;)
    }
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/tutorial/tree/master/macros/src/main/scala/scalaworld/macros/Class2Map.scala#L0-L33" target="_blank"><i class="fa fa-link "></i></a></pre>
</p>
  <h1 id="WithApply" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WithApply" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>WithApply</h1>
    Implement a <code>WithApply</code> macro annotation that creates a <code>apply</code>
    method to construct an instance of the class (just like is created for case classes).

    <p>
      The challenge here is to handle the companion object correctly.

      <ul>
        <li>
          If the companion object exists, add the <code>apply</code> method to it.</li>
        <li>
          If the companion object doesn't exists, create it.</li></ul></p>
    <p>
      Solution:
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.collection.immutable.Seq
import scala.meta._

// Before:
// @WithApply
// class WithApplyExample(a: Int)(b: String)
// After:
// class WithApplyExample(a: Int)(b: String)
// object WithApplyExample {
//   def apply(a: Int)(b: String): WithApplyExample = new WithApplyExample(a)(b)
// }

class WithApply extends scala.annotation.StaticAnnotation {
  inline def apply(defn: Any): Any = meta {
    def createApply(name: Type.Name, paramss: Seq[Seq[Term.Param]]): Defn.Def = {
      val args = paramss.map(_.map(param =&gt; Term.Name(param.name.value)))
      q&quot;&quot;&quot;def apply(...$paramss): $name =
            new ${Ctor.Ref.Name(name.value)}(...$args)&quot;&quot;&quot;
    }
    defn match {
      // companion object exists
      case Term.Block(
          Seq(cls @ Defn.Class(_, name, _, ctor, _),
              companion: Defn.Object)) =&gt;
        val applyMethod = createApply(name, ctor.paramss)
        val templateStats: Seq[Stat] =
          applyMethod +: companion.templ.stats.getOrElse(Nil)
        val newCompanion = companion.copy(
          templ = companion.templ.copy(stats = Some(templateStats)))
        Term.Block(Seq(cls, newCompanion))
      // companion object does not exists
      case cls @ Defn.Class(_, name, _, ctor, _) =&gt;
        val applyMethod = createApply(name, ctor.paramss)
        val companion   = q&quot;object ${Term.Name(name.value)} { $applyMethod }&quot;
        Term.Block(Seq(cls, companion))
      case _ =&gt;
        println(defn.structure)
        abort(&quot;@WithApply must annotate a class.&quot;)
    }
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/tutorial/tree/master/macros/src/main/scala/scalaworld/macros/WithApply.scala#L0-L43" target="_blank"><i class="fa fa-link "></i></a></pre>
</p>
  <h1 id="Debug" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Debug" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Debug</h1>
    Open up <code>Debug.scala</code> and implement a <code>Debug</code> macro annotation
    for <b>methods</b> that:

    <ul>
      <li>
        Prints out the argument names and their values at the beginning of the method.</li>
      <li>
        Prints out the time it took to run the method.</li>
      <li>
        Prints out the value of the method result.
</li></ul>
    <p>
      Solution:
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.annotation.compileTimeOnly
import scala.meta._

// Before:
// @Debug
// def complicated(a: Int, b: String)(c: Int): Int = {
//   Thread.sleep(500)
//   a + b.length + c
// }
// After:
// def complicated(a: Int, b: String)(c: Int): Int = {
//   {
//     println(&quot;a&quot; + &quot;: &quot; + a)
//     println(&quot;b&quot; + &quot;: &quot; + b)
//     println(&quot;c&quot; + &quot;: &quot; + c)
//   }
//   val start = System.currentTimeMillis()
//   val result = {
//     Thread.sleep(500)
//     a + b.length + c
//   }
//   val elapsed = System.currentTimeMillis() - start
//   println(&quot;Method &quot; + &quot;complicated&quot; + &quot; ran in &quot; + elapsed + &quot;ms&quot;)
//   result
// }
class Debug extends scala.annotation.StaticAnnotation {
  import autocomplete._
  inline def apply(defn: Any): Any = meta {
    defn match {
      case defn: Defn.Def =&gt;
        val printlnStatements = defn.paramss.flatten.map { param =&gt;
          q&quot;&quot;&quot;println(
                ${param.name.syntax} + &quot;: &quot; +
                ${Term.Name(param.name.value)})&quot;&quot;&quot;
        }
        val body: Term = q&quot;&quot;&quot;
          { ..$printlnStatements }
          val start = _root_.java.lang.System.currentTimeMillis()
          val result = ${defn.body}
          val elapsed = _root_.java.lang.System.currentTimeMillis() - start
          println(&quot;Method &quot; + ${defn.name.syntax} + &quot; ran in &quot; + elapsed + &quot;ms&quot;)
          result
          &quot;&quot;&quot;
        defn.copy(body = body)
      case _ =&gt;
        abort(&quot;@Debug most annotate a def&quot;)
    }
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/tutorial/tree/master/macros/src/main/scala/scalaworld/macros/Debug.scala#L0-L51" target="_blank"><i class="fa fa-link "></i></a></pre>
</p>
    For extra credit:
    <ul>
      <li>
        Expand the method into two methods, where one is the original method
        and the second one has a named suffixed with <code>Debug</code>
        and that's where the printing happens.
</li></ul>
  <h1 id="generic" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#generic" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>generic</h1>
    Implement a <code>generic</code> macro annotation to automatically derive
    a shapeless <code>Generic[T]</code> instance.

    <p>
      Note, macro annotations are purely syntactic, see <a href="#HowdoIgetthetypeofatree?">How do I get the type of a tree?</a>.
      As a result, to find subclasses of a sealed trait, we depend on the assumption
      that all the subclasses are put under the companion class of the sealed
      trait. The implementation below looks inside the companion class and
      extracts definitions of classes which extend the sealed trait.
</p>
    <p>
      Solution:
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.collection.immutable.Seq
import scala.meta._

// Before:
// @generic
// case class Foo(i: Int, s: String)
//
// @generic
// sealed trait Bar
// object Bar {
//   case class Baz(i: Int)     extends Bar
//   case class Quux(s: String) extends Bar
// }
//
// After:
// // infix operators are used where possible, avoiding the syntax ::[A, B]
// case class Foo(i: Int, s: String)
// object Foo {
//   implicit val FooGeneric: _root_.shapeless.Generic[Foo] =
//     new _root_.shapeless.Generic[Foo] {
//       import shapeless._
//       type Repr = Int :: String :: HNil
//       def from(r: Repr): Foo = r match {
//         case i :: s :: HNil =&gt; new Foo(i, s)
//       }
//       def to(t: Foo): Repr = t.i :: t.s :: HNil
//     }
// }
// sealed trait Bar
// object Bar {
//   implicit val BarGeneric: _root_.shapeless.Generic[Bar] =
//     new _root_.shapeless.Generic[Bar] {
//       import shapeless._
//       type Repr = Baz :+: Quux :+: CNil
//       def from(r: Repr): Bar = r match {
//         case Inl(t)      =&gt; t
//         case Inr(Inl(t)) =&gt; t
//         case Inr(Inr(cnil)) =&gt; cnil.impossible
//       }
//       def to(t: Bar): Repr = t match {
//         case t: Baz  =&gt; Inl(t)
//         case t: Quux =&gt; Inr(Inl(t))
//       }
//     }
//   case class Baz(i: Int) extends Bar()
//   case class Quux(s: String) extends Bar()
// }

// This implementation contains quite a bit of boilerplate because we
// generate similar code in term, type and pattern position.
class generic extends scala.annotation.StaticAnnotation {
  inline def apply(defn: Any): Any = meta {
    defn match {
      // Sealed ADT, create coproduct Generic.
      case Term.Block(
          Seq(t @ ClassOrTrait(mods, name), companion: Defn.Object))
          if GenericMacro.isSealed(mods) =&gt;
        val oldTemplStats = companion.templ.stats.getOrElse(Nil)
        val subTypes = oldTemplStats.collect {
          case t: Defn.Class if GenericMacro.inherits(name)(t) =&gt; t
        }
        val newStats =
          GenericMacro.mkCoproductGeneric(name, subTypes) +: oldTemplStats
        val newCompanion =
          companion.copy(templ = companion.templ.copy(stats = Some(newStats)))
        Term.Block(Seq(t, newCompanion))
      // Plain class with companion object, create HList Generic.
      case Term.Block(
          Seq(cls @ Defn.Class(_, name, _, ctor, _),
              companion: Defn.Object)) =&gt;
        val newStats =
          GenericMacro.mkHListGeneric(name, ctor.paramss) +:
            companion.templ.stats.getOrElse(Nil)
        val newCompanion =
          companion.copy(templ = companion.templ.copy(stats = Some(newStats)))
        Term.Block(Seq(cls, newCompanion))
      // Plain class without companion object, create HList Generic.
      case cls @ Defn.Class(_, name, _, ctor, _) =&gt;
        val companion =
          q&quot;&quot;&quot;object ${Term.Name(name.value)} {
                ${GenericMacro.mkHListGeneric(name, ctor.paramss)}
              }
           &quot;&quot;&quot;
        Term.Block(Seq(cls, companion))
      case defn: Tree =&gt;
        println(defn.structure)
        abort(&quot;@generic must annotate a class or a sealed trait/class.&quot;)
    }
  }
}

object GenericMacro {
  def mkCoproductTerm(depth: Int): Term =
    if (depth &lt;= 0) q&quot;Inl(t)&quot;
    else q&quot;Inr(${mkCoproductTerm(depth - 1)})&quot;

  def mkCoproductPattern(depth: Int): Pat =
    if (depth &lt;= 0) p&quot;Inl(t)&quot;
    else p&quot;Inr(${mkCoproductPattern(depth - 1)})&quot;

  // final unreachable case in `from` for coproduct generic.
  def mkCantHappen(depth: Int): Pat =
    if (depth &lt;= 0) p&quot;Inr(cnil)&quot;
    else p&quot;Inr(${mkCantHappen(depth - 1)})&quot;

  def mkGeneric(name: Type.Name,
                repr: Type,
                to: Term,
                from: Seq[Case],
                importStat: Stat): Stat = {
    val reprTyp: Stat = q&quot;type Repr = $repr&quot;
    val toDef: Stat   = q&quot;def to(t: $name): Repr = $to&quot;
    val fromDef: Stat =
      q&quot;def from(r: Repr): $name = r match { ..case $from }&quot;
    val implicitName = Pat.Var.Term(Term.Name(name.syntax + &quot;Generic&quot;))

    q&quot;&quot;&quot;implicit val $implicitName: _root_.shapeless.Generic[$name] =
            new _root_.shapeless.Generic[$name] {
              $importStat
              $reprTyp
              $toDef
              $fromDef
            }
       &quot;&quot;&quot;
  }

  def mkCoproductGeneric(superName: Type.Name,
                         subTypes: Seq[Defn.Class]): Stat = {
    val coproductType: Type = subTypes.foldRight[Type](t&quot;CNil&quot;) {
      case (cls, accum) =&gt;
        t&quot;${cls.name} :+: $accum&quot;
    }
    val coproductTermCases: Seq[Case] = subTypes.zipWithIndex.map {
      case (cls, i) =&gt;
        p&quot;case t: ${cls.name} =&gt; ${mkCoproductTerm(i)}&quot;
    }
    val coproductTerm = q&quot;t match { ..case $coproductTermCases }&quot;
    val coproductPat: Seq[Case] = subTypes.zipWithIndex.map {
      case (cls, i) =&gt;
        p&quot;case ${mkCoproductPattern(i)} =&gt; t&quot;
    }
    val cantHappen =
      p&quot;&quot;&quot;case ${mkCantHappen(subTypes.length - 1)} =&gt;
              cnil.impossible
         &quot;&quot;&quot;
    mkGeneric(superName,
              coproductType,
              coproductTerm,
              coproductPat :+ cantHappen,
              q&quot;import shapeless.{CNil, :+:, Inr, Inl}&quot;)
  }

  def mkHListGeneric(name: Type.Name, paramss: Seq[Seq[Term.Param]]): Stat = {
    val params = paramss match {
      case params :: Nil =&gt; params
      case _             =&gt; abort(&quot;Can't create generic for curried functions yet.&quot;)
    }
    val hlistType: Type = params.foldRight[Type](t&quot;HNil&quot;) {
      case (Term.Param(_, _, Some(decltpe: Type), _), accum) =&gt;
        t&quot;$decltpe :: $accum&quot;
      case (param, _) =&gt;
        abort(s&quot;Unsupported parameter ${param.syntax}&quot;)
    }
    val hlistTerm: Term = params.foldRight[Term](q&quot;HNil&quot;) {
      case (param, accum) =&gt;
        q&quot;t.${Term.Name(param.name.value)} :: $accum&quot;
    }
    val hlistPat: Pat = params.foldRight[Pat](q&quot;HNil&quot;) {
      case (param, accum) =&gt;
        p&quot;${Pat.Var.Term(Term.Name(param.name.value))} :: $accum&quot;
    }
    val args = params.map(param =&gt; Term.Name(param.name.value))
    val patmat =
      p&quot;case $hlistPat =&gt; new ${Ctor.Ref.Name(name.value)}(..$args)&quot;
    mkGeneric(name,
              hlistType,
              hlistTerm,
              Seq(patmat),
              q&quot;import shapeless.{::, HNil}&quot;)
  }

  def isSealed(mods: Seq[Mod]): Boolean = mods.exists(_.syntax == &quot;sealed&quot;)

  // Poor man's semantic API, we check that X in `class Foo extends X`
  // matches syntactically the name of the annotated sealed type.
  def inherits(superType: Type.Name)(cls: Defn.Class): Boolean =
    cls.templ.parents.headOption.exists {
      case q&quot;$parent()&quot; =&gt; parent.syntax == superType.syntax
      case _            =&gt; false
    }
}

object ClassOrTrait {
  def unapply(any: Defn): Option[(Seq[Mod], Type.Name)] = any match {
    case t: Defn.Class =&gt; Some((t.mods, t.name))
    case t: Defn.Trait =&gt; Some((t.mods, t.name))
    case _             =&gt; None
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/tutorial/tree/master/macros/src/main/scala/scalaworld/macros/generic.scala#L0-L201" target="_blank"><i class="fa fa-link "></i></a></pre>
</p>
  <h1 id="Testingmacroannotations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Testingmacroannotations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Testing macro annotations</h1>
    See MainTest for an example of to both unit test and integration test a
    macro annotation.
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.meta._
import scala.meta.testkit._
import java.io.ByteArrayOutputStream
import java.io.PrintStream
import org.scalatest.FunSuite

// If you are doing complicated macro expansions, it's recommeded to unit test
// the trickiest bits instead of relying only on integration tests.
class MainUnitTest extends FunSuite {

  // TODO(olafur) this method should be exposed in testkit
  def assertStructurallyEqual(obtained: Tree, expected: Tree): Unit = {
    StructurallyEqual(obtained, expected) match {
      case Left(AnyDiff(x, y)) =&gt;
        fail(s&quot;&quot;&quot;Not Structurally equal!:
                |obtained: $x
                |expected: $y
             &quot;&quot;&quot;.stripMargin)
      case _ =&gt;
    }
  }

  test(&quot;@Main creates a main method&quot;) {
    val obtained = MainMacroImpl.expand(q&quot;AnswerToEverything&quot;,
                                        List(q&quot;val x = 42&quot;, q&quot;println(x)&quot;))
    val expected =
      q&quot;&quot;&quot;
        object AnswerToEverything {
          def main(args: Array[String]): Unit = {
            val x = 42
            println(x)
          }
        }
       &quot;&quot;&quot;
    assertStructurallyEqual(obtained, expected)
  }
}

// This is an integration tests because it requires running the macro expansion
// through the entire compiler pipeline, if you have a bug in your macro annotation
// the expanded code may not compile causing your test suite to not compile.
class MainIntegrationTest extends FunSuite {
  test(&quot;@Main creates a main method&quot;) {
    val out: ByteArrayOutputStream = new ByteArrayOutputStream()
    Console.withOut(new PrintStream(out)) {
      MainExample.main(Array())
    }
    assert(out.toString.stripLineEnd == &quot;Hello Scalameta macros!&quot;)
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/tutorial/tree/master/macros/src/test/scala/scalaworld/macros/MainTest.scala#L0-L52" target="_blank"><i class="fa fa-link "></i></a></pre>


  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="SemanticAPI" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Semantic API<a class=" scalatex-site-Styles-headerLink" href="#SemanticAPI" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  The Scalameta Semantic API offers operations to query information from the Scala
  compiler such as naming resolution (<code>println</code> =&gt; <code>_root_.scala.Predef.println</code>),
  inferred type annotations, reported compiler messages and more.
  These operations can for example be used by tools like
  <a href="https://scalacenter.github.io/scalafix">scalafix</a> to refactor Scala code.
  The Semantic API cannot be used from <a href="#Macroannotations">Macro annotations</a>.

  <h1 id="Mirror" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Mirror" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Mirror</h1>
    The Semantic API is based on the concept of mirrors.
    In Scalameta parlance, a mirror is an entity that encapsulates a compilation
    context, providing a classpath and a sourcepath to perform semantic operations
    such as name resolution, type inference and others.
    Most Semantic APIs take an implicit parameter of type Mirror.

    <p>
      Unlike the syntactic API, which is implemented completely in house,
      Scalameta delegates implementations of Mirror to external projects.
      In Scala, performing even the simplest semantic operations requires a
      full-blown typechecker, so implementing even a simple Mirror in house would
      require us to reinvent a Scala typechecker, which is a multi-man-year effort.
      Currently, we provide a Mirror implementation that is backed by the Scala
      compiler, and there are plans to implement mirrors for Dotty and IntelliJ.
</p>
  <h1 id="SemanticDB" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#SemanticDB" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Semantic DB</h1>
    <p>
      One of the properties of semantic databases is their <b>portability</b>. Unlike
      typical representations of semantic information in Scala, semantic
      databases are not tied to a particular implementation of the Scala
      typechecker. This makes it possible for metaprograms written against the
      scala.meta Semantic API to run on multiple platforms.
</p>
    <p>
      Another important property is <b>persistence</b>. Since semantic databases are
      portable, they can be created and consumed in separate environments. This
      is a key insight that we promote in scala.meta, and we are confident that
      it will revolutionize the developer tool ecosystem in Scala.
</p>
    <p>
      Currently, a typical approach to semantic developer tools in Scala is
      implementing them as compiler plugins and then using them inside builds.
      Apart from being a hassle to configure, this approach is also quite slow,
      because it needs to run a Scala typechecker every time when a tool is
      invoked.
</p>
    <p>
      Scala.meta enables a much more convenient workflow. First, we use our
      scalahost compiler plugin to typecheck a given codebase and generate a
      semantic database for it. This is done only once per unique snapshot of the
      codebase. Afterwards, using the persisted semantic database, we can launch
      any number of developer tools any number of times without having to
      typecheck the codebase again.</p>
    <p>
      The storage format used for the Semantic DB is defined using
      <a href="https://www.google.ch/search?q=protocol+buffers&amp;oq=protocol+buffer&amp;aqs=chrome.0.0j69i61j69i57j69i61j0l2.6856j0j7&amp;sourceid=chrome&amp;ie=UTF-8">Protocol Buffers</a>,
      or &quot;protobuf&quot; for short.  The Semantic DB protobuf schema is small, at
      the time of this writing it is ~50 lines of code.  The full schema is
      available
      <a href="https://github.com/scalameta/scalameta/blob/master/scalameta/semantic/shared/src/main/protobuf/semanticdb.proto">here</a>.
      Files containing Semantic DB binary data use the <code>.semanticdb</code> file
      extension.
</p>
  <h1 id="Scalahost" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Scalahost" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Scalahost</h1>
    To build a <a href="#SemanticDB">Semantic DB</a> with the Scala 2.x compiler, you will need
    the &quot;Scalahost&quot; compiler plugin.
    The Scalahost compiler plugin is developed in the main Scalameta repository.
    There are several ways to <a href="#Installation">install</a> Scalahost into your build.

  <h1 id="Installation" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Installation" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Installation</h1>
    The setup to run the Semantic API is more involved than running the
    Syntactic API (parsing/tokenizing).
    Most importantly, we first need to compile source files with the Scala compiler
    in order to collect information such as types, symbols and more.
    It's possible to tokenize or parse code that doesn't compile.  However, in
    order to analyze a file with the Semantic API, the file must be able to compile.

    


<h2 id="sbt-semantic-example" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#sbt-semantic-example" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>sbt-semantic-example</h2>
  For plug and play example, clone
  <a href="https://github.com/scalameta/sbt-semantic-example">sbt-semantic-example</a>
  and follow the readme instructions.

<h2 id="sbt" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#sbt" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>sbt</h2>
  <pre><code class="scala scalatex-site-Styles-highlightMe">lazy val scalahostSettings = Seq(
  addCompilerPlugin(&quot;org.scalameta&quot; % &quot;scalahost&quot; % &quot;1.8.0&quot; cross CrossVersion.full),
  scalacOptions ++= Seq(
    &quot;-Yrangepos&quot;,
    &quot;-Xplugin-require:scalahost&quot;
  )
)
</code></pre>
  Add the following settings your project like this

  <pre><code class="scala scalatex-site-Styles-highlightMe">lazy val analyzeMe = project.settings(
  // Scalahost supports the Scala versions: 2.11.11, 2.12.2.
  // Note, the Scala version must match down to the latest (PATCH) number.
  scalaVersion := &quot;2.11.11&quot;,
  scalahostVersions
)
</code></pre>
<h2 id="Otherbuildtools" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Otherbuildtools" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Other build tools</h2>
  You can use Scalahost outside of sbt by passing in custom scalac flags.
  <pre><code class="scala scalatex-site-Styles-highlightMe">// -Xplugin-require:scalahost tells scalac to fail fast if Scalahost failed to load
// -Yrangepos is required by Scalahost
scalac -Xplugin:/path/to/scalahost.jar -Yrangepos -Xplugin-require:scalahost Code.scala
</code></pre>
<h2 id="scalameta/tutorialsemantic/run" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#scalameta/tutorialsemantic/run" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>scalameta/tutorial semantic/run</h2>
  If you have cloned the repo for this tutorial as explained in
  <a href="#Tutorial">Tutorial</a>, you can execute <code>sbt semantic/run</code> to run
  an example application using the semantic API.

<h2 id="Coursier" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Coursier" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Coursier</h2>
  If you have <a href="https://github.com/coursier/coursier">coursier</a> installed,
  you can run this one-liner assuming you want to analyze a source file <code>Foo.scala</code>

  <pre><code class="scala scalatex-site-Styles-highlightMe">// make sure the version of scalac is 2.11.11
scalac -Yrangepos -Xplugin-require:scalahost -Xplugin:$(coursier fetch --intransitive org.scalameta:scalahost_2.11.11:1.8.0) Foo.scala

</code></pre>
<h2 id="Verifyinstallation" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Verifyinstallation" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Verify installation</h2>
  To verify that the Scalahost compiler plugin is installed
  <ul>
    <li>
      make sure that you are compiling least one source file</li>
    <li>
      clean</li>
    <li>
      compile</li>
    <li>
      look into the target/ directory for files with the file extension <code>.semanticdb</code>.
      The files will appear under a directory called <code>META-INF/semanticdb</code>.
</li></ul>
  If you cannot find any <code>.semanticdb</code> files, then something went wrong with the setup.
  Don't hesitate to ask questions on <a href="https://gitter.im/scalameta/scalameta?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/scalameta/scalameta" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a>.


  <h1 id="Example" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Example" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Example</h1>

    <p>
      Let's take a look at the inside of a <code>.semanticdb</code> file.
      Given a source file <code>Input.scala</code>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.semantic

case class Input(x: Int) {
  def +(other: Input) = Input(x + other.x)
  def +(other: Int) = Input(x + other)
  1 + 2
  List(x).map(num =&gt; Input(num + 1) + Input(2) + 3)
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/tutorial/tree/master/semantic/input/src/main/scala/scalaworld/semantic/Input.scala#L0-L11" target="_blank"><i class="fa fa-link "></i></a></pre>
      the pretty printed representation of its corresponding <code>Input.semanticdb</code>
      is the following:
      <pre><code class="scala scalatex-site-Styles-highlightMe">semantic/input/src/main/scala/scalaworld/semantic/Input.scala
-------------------------------------------------------------
Dialect:
Scala211

Names:
[8..18): scalaworld =&gt; _root_.scalaworld.
[19..27): semantic =&gt; _root_.scalaworld.semantic.
[40..45): Input =&gt; _root_.scalaworld.semantic.Input#
[46..47): x =&gt; _root_.scalaworld.semantic.Input#(x)
[49..52): Int =&gt; _root_.scala.Int#
[62..63): + =&gt; _root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.
[64..69): other =&gt; _root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.(other)
[71..76): Input =&gt; _root_.scalaworld.semantic.Input#
[80..85): Input =&gt; _root_.scalaworld.semantic.Input.
[86..87): x =&gt; _root_.scalaworld.semantic.Input#(x)
[88..89): + =&gt; _root_.scala.Int#`+`(I)I.
[90..95): other =&gt; _root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.(other)
[96..97): x =&gt; _root_.scalaworld.semantic.Input#(x)
[105..106): + =&gt; _root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.
[107..112): other =&gt; _root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.(other)
[114..117): Int =&gt; _root_.scala.Int#
[121..126): Input =&gt; _root_.scalaworld.semantic.Input.
[127..128): x =&gt; _root_.scalaworld.semantic.Input#(x)
[129..130): + =&gt; _root_.scala.Int#`+`(I)I.
[131..136): other =&gt; _root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.(other)
[142..143): + =&gt; _root_.scala.Int#`+`(I)I.
[148..152): List =&gt; _root_.scala.collection.immutable.List.
[153..154): x =&gt; _root_.scalaworld.semantic.Input#(x)
[156..159): map =&gt; _root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;.
[160..163): num =&gt; semantic/input/src/main/scala/scalaworld/semantic/Input.scala@160..163
[167..172): Input =&gt; _root_.scalaworld.semantic.Input.
[173..176): num =&gt; semantic/input/src/main/scala/scalaworld/semantic/Input.scala@160..163
[177..178): + =&gt; _root_.scala.Int#`+`(I)I.
[182..183): + =&gt; _root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.
[184..189): Input =&gt; _root_.scalaworld.semantic.Input.
[193..194): + =&gt; _root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.

Messages:
[140..145): [warning] a pure expression does nothing in statement position; you may be omitting necessary parentheses

Denotations:
_root_.scalaworld.semantic.Input# =&gt; case class Input
_root_.scalaworld.semantic.Input#(x) =&gt; val param x: Int
_root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;. =&gt; def +: (other: Int)scalaworld.semantic.Input
_root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.(other) =&gt; param other: Int
_root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;. =&gt; def +: (other: scalaworld.semantic.Input)scalaworld.semantic.Input
_root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.(other) =&gt; param other: scalaworld.semantic.Input
_root_.scalaworld.semantic.Input#`&lt;init&gt;`(I)V. =&gt; primaryctor &lt;init&gt;: (x: Int)scalaworld.semantic.Input
semantic/input/src/main/scala/scalaworld/semantic/Input.scala@160..163 =&gt; param num: Int

Sugars:
[152..152) [Int]
[159..159) [scalaworld.semantic.Input, List[scalaworld.semantic.Input]]
[197..197) (scala.collection.immutable.List.canBuildFrom[scalaworld.semantic.Input])
</code></pre>
      That is a lot of output, let's take a closer look at each of
      the sections:
      <a href="#Names">Names</a>,
      <a href="#Messages">Messages</a>,
      <a href="#Denotations">Denotations</a>, and
      <a href="#Sugars">Sugars</a>.
</p>
  <h1 id="Names" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Names" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Names</h1>
    <p>
      The <code>Names</code> section is a map from names/identifiers to the <a href="#Symbol">Symbol</a> they reference.
      A name is an identifier such as <code>List</code> or <code>+</code>.
      A name can have different symbols depending on where the name appears.
      For example, <code>+</code> references three different symbols in the example above
      <pre><code class="scala scalatex-site-Styles-highlightMe">// Int + Int
[88..89): +   =&gt; _root_.scala.Int#`+`(I)I.
// Bar + Bar
[62..63): +   =&gt; _root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.
// Bar + Int
[105..106): + =&gt; _root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.
</code></pre></p>
  <h1 id="Denotations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Denotations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Denotations</h1>
    The <code>Denotations</code> section is a map from <a href="#Symbol">Symbol</a>s that appear
    in the source file to the <a href="#Denotation">Denotation</a> of the symbol.

  <h1 id="Messages" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Messages" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Messages</h1>
    The <code>Messages</code> section is a list of the reporter compiler messages (info/warn/error).
    Note, some reported messages like deprecation warnings are not yet collected, see <a href="http://scalameta.org/tutorial/issues/759">#759</a>.

  <h1 id="Sugars" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Sugars" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Sugars</h1>
    <b>EXPERIMENTAL/NEW</b>.
    The <code>Sugars</code> section is a list &quot;sugars&quot; that are inserted by the compiler.
    Sugars don't have positions in the original source file.
    Sugars include inferred type parameters, type annotations of definitions
    and implicit arguments.
    Note that sugars are currently not enriched with semantic information
    such as symbols or denotations, see <a href="http://scalameta.org/tutorial/issues/822">#822</a>.

  <h1 id="Symbol" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Symbol" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Symbol</h1>
    Every definition such as a class/trait/val/var/def/object has a unique identifier.
    This unique identifier is called a <code>Symbol</code>.
    The string representation of a symbol is the erased JVM signature of the definition.
    This makes it possible to distinguish between overloaded methods.
    To understand what a symbol means, inspect its <a href="#Denotation">Denotation</a>.

  <h1 id="Denotation" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Denotation" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Denotation</h1>
    A denotation represents a <a href="#Symbol">Symbol</a>'s meaning, including modifiers,
    annotations, visibility restrictions and type signature.
    A denotation can for example tell you if a definition is a trait or a class,
    of if it has the <code>implicit</code> modifier.


  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Contrib" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Contrib<a class=" scalatex-site-Styles-headerLink" href="#Contrib" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  Scalameta contrib is a module that provides common utilities for handling
  Scalameta data structures.

  <p>
    To use contrib, <code>import scala.meta.contrib._</code>.
</p>
  <p>
    Contrib exposes some collection-like methods on <code>Tree</code>.
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; source&quot;&quot;&quot;
class A
trait B
object C
object D
&quot;&quot;&quot;.find(_.is[Defn.Object])
res0: Option[scala.meta.Tree] = Some(object C)

scala&gt; source&quot;&quot;&quot;
class A
trait B
object C {
  val x = 2
  val y = 3
}
object D
&quot;&quot;&quot;.collectFirst { case q&quot;val y = $body&quot; =&gt;  body.structure }
res1: Option[String] = Some(Lit.Int(3))

scala&gt; source&quot;&quot;&quot;
class A
trait B
object C {
  val x = 2
  val y = 3
}
object D
&quot;&quot;&quot;.exists(_.is[Defn.Def])
res2: Boolean = false</code></pre></p>
  <p>
    Contrib has a <code>Equal</code> typeclass for comparing trees by structural or
    syntactic equality.
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;val x = 2&quot;.isEqual(q&quot;val x = 1&quot;)
res0: Boolean = false

scala&gt; (q&quot;val x = 2&quot;: Stat).isEqual(&quot;val x = 2 // comment&quot;.parse[Stat].get)
res1: Boolean = true

scala&gt; (q&quot;val x = 2&quot;: Stat).isEqual[Syntactically](&quot;val x = 2 // comment&quot;.parse[Stat].get)
res2: Boolean = false

scala&gt; q&quot;lazy val x = 2&quot;.mods.exists(_.isEqual(mod&quot;lazy&quot;))
res3: Boolean = true

scala&gt; q&quot;lazy val x = 2&quot;.contains(q&quot;3&quot;)
res4: Boolean = false

scala&gt; q&quot;lazy val x = 2&quot;.contains(q&quot;2&quot;)
res5: Boolean = true</code></pre></p>
  <p>
    Contrib has an <code>AssociatedCommments</code> helper to extract leading
    and trailing comments of tree nodes.
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; val code: Source = &quot;&quot;&quot;
/** This is a docstring */
trait MyTrait // leading comment
&quot;&quot;&quot;.parse[Source].get
code: scala.meta.Source =

/** This is a docstring */
trait MyTrait // leading comment

scala&gt; val comments = AssociatedComments(code)
comments: scala.meta.contrib.AssociatedComments = scala.meta.contrib.AssociatedComments$$anon$1@2802f13d

scala&gt; val myTrait = code.find(_.is[Defn.Trait]).get
myTrait: scala.meta.Tree = trait MyTrait

scala&gt; comments.leading(myTrait) -&gt; comments.trailing(myTrait)
res0: (Set[meta.tokens.Token.Comment], Set[meta.tokens.Token.Comment]) = (Set(/** This is a docstring */),Set(// leading comment))</code></pre></p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="FAQ" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">FAQ<a class=" scalatex-site-Styles-headerLink" href="#FAQ" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>

  <h1 id="HowdoIgetthetypeofatree?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HowdoIgetthetypeofatree?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>How do I get the type of a tree?</h1>
    It is not possible to query for type information from a macro annotation.
    Macro annotations are purely syntactic, and there is no plan to add support
    for capabilities such as getting the fields/member of a type/class. Why?
    Because you hit on chicken vs. egg problems. There
    is a cyclic dependency between
    <ul>
      <li>
        type checking source code to provide type information</li>
      <li>
        expanding a macro annotation to generate new definitions.
</li></ul>
    The generated definitions are necessary to type check the source file,
    and the type checker is necessary provide type information to the macro
    annotation.


  <h1 id="WherecanIaskmorequestions?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WherecanIaskmorequestions?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Where can I ask more questions?</h1>
    <ul>
      <li>
        use the
        <a href="http://stackoverflow.com/questions/tagged/scala-meta">scala-meta</a>.
        tag on Stack Overflow.</li>
      <li>
        We also have a Gitter channel
        
          <a href="https://gitter.im/scalameta/scalameta?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/scalameta/scalameta" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a>
</li></ul>
  <h1 id="HowdoItestamacroannotation?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HowdoItestamacroannotation?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>How do I test a macro annotation?</h1>
    You can either unit test or integration test your macro annotation.
    See <a href="#Testingmacroannotations">Testing macro annotations</a>

  <h1 id="Howdoidentifyaparticularannotation?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Howdoidentifyaparticularannotation?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>How do identify a particular annotation?</h1>
    Maybe this help, <a href="https://stackoverflow.com/questions/43394357/scalameta-identify-particular-annotations">https://stackoverflow.com/questions/43394357/scalameta-identify-particular-annotations</a>

  <h1 id="WhatisthequasiquoteforX?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WhatisthequasiquoteforX?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>What is the quasiquote for X?</h1>
    Here is an overview of quasiquote syntax: <a href="https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md">https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md</a>.

  <h1 id="';'expectedbut'def'found.inlinedefapply" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#';'expectedbut'def'found.inlinedefapply" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>';' expected but 'def' found. inline def apply</h1>
    Be sure that the org.scalameta:paradise compiler plugin is enabled.

  <h1 id="CanIuseScalametawithScala.js?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CanIuseScalametawithScala.js?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Can I use Scalameta with Scala.js?</h1>
    Yes, the main Scalameta modules support Scala.js.

  <h1 id="HowdoIpassanargumenttothemacroannotation?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HowdoIpassanargumenttothemacroannotation?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>How do I pass an argument to the macro annotation?</h1>
    You match on <code>this</code> as a Scalameta tree. For example:

    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.meta._

class Argument(arg: Int) extends scala.annotation.StaticAnnotation {
  inline def apply(defn: Any): Any = meta {
    // `this` is a scala.meta tree.
    println(this.structure)
    val arg = this match {
      // The argument needs to be a literal like `1` or a string like `&quot;foobar&quot;`.
      // You can't pass in a variable name.
      case q&quot;new $_(${Lit.Int(arg)})&quot; =&gt; arg
      // Example if you have more than one argument.
      case q&quot;new $_(${Lit.Int(arg)}, ${Lit.String(foo)})&quot; =&gt; arg
      case _  =&gt; ??? // default value
    }
    println(s&quot;Arg is $arg&quot;)
    defn.asInstanceOf[Stat]
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/tutorial/tree/master/macros/src/main/scala/scalaworld/macros/Argument.scala#L0-L20" target="_blank"><i class="fa fa-link "></i></a></pre>

  <h1 id="DoIneedtodependonScalametaatruntime?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#DoIneedtodependonScalametaatruntime?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Do I need to depend on Scalameta at runtime?</h1>
    No. But your project needs a dependency on Scalameta.
    If you only use Scalameta at compile time, you can mark the dependency as
    <code>% &quot;provided&quot;</code> to exclude it from your runtime application.

  <h1 id="HowdoIusemacroannotationsprovidedbyathird-partylibrary?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HowdoIusemacroannotationsprovidedbyathird-partylibrary?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>How do I use macro annotations provided by a third-party library?</h1>
    If your project depends on a library that provides macro annotations, you need
    to enable the `paradise` compiler plugin and declare a dependency on `scala-meta`
    so that macro annotations could be expanded:

    <pre><code class="scala scalatex-site-Styles-highlightMe">addCompilerPlugin(
  (&quot;org.scalameta&quot; % &quot;paradise&quot; % paradiseVersion).cross(CrossVersion.full)
)

libraryDependencies +=
  &quot;org.scalameta&quot; %% &quot;scalameta&quot; % scalametaVersion % Provided

</code></pre>
    Here is a complete `settings` definition necessary and sufficient to enable
    dependent project to use the library (including workarounds for features
    that are being currently worked on):

    <pre><code class="scala scalatex-site-Styles-highlightMe">lazy val enableMacroAnnotations: Seq[Def.Setting[_]] = Seq(
  addCompilerPlugin(&quot;org.scalameta&quot; % &quot;paradise&quot; % paradiseVersion cross CrossVersion.full),
  libraryDependencies += &quot;org.scalameta&quot; %% &quot;scalameta&quot; % scalametaVersion % Provided,
  scalacOptions += &quot;-Xplugin-require:macroparadise&quot;,
  // macroparadise plugin doesn't work in repl yet.
  scalacOptions in (Compile, console) := Seq()
)
</code></pre>
  <h1 id="HowdoIreusecodebetweenmacros?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HowdoIreusecodebetweenmacros?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>How do I reuse code between macros?</h1>
    If you try to call a method inside you macro class you get a &quot;X not found&quot; error.

    <pre><code class="scala scalatex-site-Styles-highlightMe">class Argument(arg: Int) extends scala.annotation.StaticAnnotation {
  def helper(t: Any): Stat = ??? // utility method
  inline def apply(defn: Any): Any = meta {
    helper(defn) // ERROR: `helper` not found
    // Why? `this` is a Scalameta tree.
}
</code></pre>
    You can move the utility method to an external object.

    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.meta._

object MacroUtil {
  def helper(defn: Any): Stat = q&quot;class ReuseExample&quot;
}

class Reuse extends scala.annotation.StaticAnnotation {
  inline def apply(defn: Any): Any = meta {
    MacroUtil.helper(defn)
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/tutorial/tree/master/macros/src/main/scala/scalaworld/macros/MacroUtil.scala#L0-L13" target="_blank"><i class="fa fa-link "></i></a></pre>

  <h1 id="Incrementalcompilerismessingup/stalecode" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Incrementalcompilerismessingup/stalecode" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Incremental compiler is messing up / stale code</h1>
    While editing the macro, it can be handy to keep this command
    running in SBT
    <pre><code class="scala scalatex-site-Styles-highlightMe">~; macros/test:clean ; macros/test:run</code></pre>
    Incremental compilation caches the macro expansion you need to clean the
    test project on every run.

  <h1 id="MyIDE/IntelliJshowsredsquigglymarks" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#MyIDE/IntelliJshowsredsquigglymarks" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>My IDE/IntelliJ shows red squiggly marks</h1>

    Your IDE might be all red like this
    <div class="text-center"><img style="width: 100%" src="img/inline.png" /><p></p></div>
    There are two possible workarounds:

    <ol>
      <li>
        (Recommended if using IntelliJ)
        First, install the
        <a href="https://confluence.jetbrains.com/display/IDEADEV/IDEA+2016.3+EAP">2016.3 EAP</a>.
        Then, select nightly or EAP update channel from Updates tab in Scala plugin settings
        <code>Settings -&gt; Languages and frameworks -&gt; Scala -&gt; Updates</code>.</li>
      <li>
        (hack)
        Add <code>import autocomplete._</code> to your file and a semicolon after <code>inline</code>,
        like this
        <div class="text-center"><img style="width: 100%" src="img/inline2.png" /><p></p></div>
        Remember to remove the semicolon when you run your macro.</li></ol>
  <h1 id="New-styledefmacros" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#New-styledefmacros" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>New-style def macros</h1>
    Scalameta doesn't yet provide a possibility to write new-style <b>def</b> macros,
    but we are working hard on implementing this functionality.
    Attend
    <a href="https://skillsmatter.com/conferences/7432-scala-exchange-2016#program">Eugene Burmako's talk at Scala eXchange 2016</a>
    to learn more about our progress.


  <h1 id="Compatibilitywithtraditionalmacros" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Compatibilitywithtraditionalmacros" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Compatibility with traditional macros</h1>
    <p>
      At the moment, new-style macros can only take apart existing Scala syntax
      and generate new syntax (so called syntactic API). This corresponds to the
      functionality provided by traditional macro annotations that only use
      tree constructors and quasiquotes.
</p>
    <p>
      Even this limited functionality should be enough to port most of the
      existing macro annotations to Scalameta. Oleksandr Olgashko has ported
      <a href="https://gitter.im/mpilquist/simulacrum?at=57fd4a7e68f560d80cf89330">a large subset of Simulacrum's @typeclass features</a>
      to new-style macros,
      so we are confident that new-style macros are powerful enough to support
      even more complex annotations.
</p>
    <p>
      For new-style def macros, we are working on semantic API, which will
      provide compiler information such as type inference, name resolution and
      other functionality that requires typechecking.
      It is too early to tell how compatible this API will be with what is
      provided by scala.reflect. We will provide more information as the design
      of the semantic API shapes up.

</p>
  <h1 id="WhichversionsofScaladotheScalametamacrossupport?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WhichversionsofScaladotheScalametamacrossupport?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Which versions of Scala do the Scalameta macros support?</h1>
    2.11.x and 2.12.x.

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Resources" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Resources<a class=" scalatex-site-Styles-headerLink" href="#Resources" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>

  <ul>
    <li>
      Scalameta website: <a href="http://scalameta.org">http://scalameta.org</a></li>
    <li>
      Please report macro annotation bug issues to Scalameta paradise:
      <a href="https://github.com/scalameta/paradise/">https://github.com/scalameta/paradise/</a>.</li>
    <li>
      For more macro annotation examples, see
      <a href="https://github.com/DavidDudson/Elysium">Elysium</a>.</li></ul>

  



  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <style>
    .bs-callout-danger {
      border-left-color: #ce4844 !IMPORTANT;
    }
    .bs-callout-danger h4 {
      color: #ce4844 !IMPORTANT;
    }
    .bs-callout-warning {
      border-left-color: #aa6708 !IMPORTANT;
    }
    .bs-callout-warning h4 {
      color: #aa6708 !IMPORTANT;
    }
    .bs-callout-info {
      border-left-color: #1b809e !IMPORTANT;
    }
    .bs-callout-info h4 {
      color: #1b809e !IMPORTANT;
    }
    .bs-callout-success {
      border-left-color: #5cb85c !IMPORTANT;
    }
    .bs-callout {
        padding: 20px;
        margin: 20px 0;
        border: 1px solid #eee;
        border-left-width: 5px;
        border-radius: 3px;
    }
    .scalatex-site-Styles-headerTag {
      margin-bottom: 20px !important;
    }
  </style>

</div>

  <script type="text/javascript">
    var _paq = _paq || [];
    _paq.push(["setDomains", ["*.scalameta.org"]]);
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
      var u="https://stats.geirsson.com/hello/";
      _paq.push(['setTrackerUrl', u+'hello.php']);
      _paq.push(['setSiteId', 4]);
      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
      g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'hello.js'; s.parentNode.insertBefore(g,s);
    })();
  </script>
  <noscript><p><img src="https://stats.geirsson.com/hello/hello.php?idsite=4" style="border:0;" alt="" /></p></noscript>
</div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"A Whirlwind Tour of Scalameta","children":[{"value":"Setup","children":[{"value":"Library","children":[]},{"value":"Tutorial","children":[]},{"value":"Ammonite REPL","children":[]},{"value":"Video","children":[]}]},{"value":"Tokens","children":[{"value":"Tokens.syntax","children":[]},{"value":"Tokens.structure","children":[]},{"value":"Tokens vs. Token","children":[]},{"value":"==","children":[]},{"value":".get","children":[]},{"value":"Conclusion","children":[]}]},{"value":"Trees","children":[{"value":"q\"Quasiquotes\"","children":[]},{"value":".parse[T]","children":[]},{"value":"dialects","children":[]},{"value":"Tree.syntax","children":[]},{"value":"Tree.structure","children":[]},{"value":"Tree.collect","children":[]},{"value":"Tree.transform","children":[]},{"value":"Tree.==","children":[]},{"value":"Comprehensive trees","children":[]}]},{"value":"Macro annotations","children":[{"value":"Setup build","children":[]},{"value":"Hello World","children":[]},{"value":"Class2Map","children":[]},{"value":"WithApply","children":[]},{"value":"Debug","children":[]},{"value":"generic","children":[]},{"value":"Testing macro annotations","children":[]}]},{"value":"Semantic API","children":[{"value":"Mirror","children":[]},{"value":"Semantic DB","children":[]},{"value":"Scalahost","children":[]},{"value":"Installation","children":[{"value":"sbt-semantic-example","children":[]},{"value":"sbt","children":[]},{"value":"Other build tools","children":[]},{"value":"scalameta/tutorial semantic/run","children":[]},{"value":"Coursier","children":[]},{"value":"Verify installation","children":[]}]},{"value":"Example","children":[]},{"value":"Names","children":[]},{"value":"Denotations","children":[]},{"value":"Messages","children":[]},{"value":"Sugars","children":[]},{"value":"Symbol","children":[]},{"value":"Denotation","children":[]}]},{"value":"Contrib","children":[]},{"value":"FAQ","children":[{"value":"How do I get the type of a tree?","children":[]},{"value":"Where can I ask more questions?","children":[]},{"value":"How do I test a macro annotation?","children":[]},{"value":"How do identify a particular annotation?","children":[]},{"value":"What is the quasiquote for X?","children":[]},{"value":"';' expected but 'def' found. inline def apply","children":[]},{"value":"Can I use Scalameta with Scala.js?","children":[]},{"value":"How do I pass an argument to the macro annotation?","children":[]},{"value":"Do I need to depend on Scalameta at runtime?","children":[]},{"value":"How do I use macro annotations provided by a third-party library?","children":[]},{"value":"How do I reuse code between macros?","children":[]},{"value":"Incremental compiler is messing up / stale code","children":[]},{"value":"My IDE/IntelliJ shows red squiggly marks","children":[]},{"value":"New-style def macros","children":[]},{"value":"Compatibility with traditional macros","children":[]},{"value":"Which versions of Scala do the Scalameta macros support?","children":[]}]},{"value":"Resources","children":[]}]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   